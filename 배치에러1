`if not`을 사용할 때 `errorlevel`이 `0`을 반환하는 이유는 **`if not` 조건 자체가 `cmd` 실행 흐름을 제어하면서, 그 조건에 따라 명령이 실행되지 않았기 때문**입니다. 이에 따라 `cmd`는 `if not` 블록 안에서의 결과를 처리할 때 `errorlevel` 상태를 초기화하거나 변경하지 않는 경우가 생깁니다.

### 문제의 원인
1. **`if not`의 기본 동작**: 
   - `if not` 조건문은 비교만 수행하며, 명령어 실행이 발생하지 않을 수도 있습니다.
   - 이 과정에서 `errorlevel`이 명령어 실패 여부와 무관하게 초기화되거나 유지될 가능성이 있습니다.

2. **명령어 실행 순서의 문제**: 
   - `if not` 블록 내부에서 `copy` 명령이 실행되지 않거나, 비교 자체가 실패해도 `errorlevel` 상태는 이전 명령의 상태를 유지할 수 있습니다.
   - `if not` 조건문이 참 또는 거짓을 판별하는 중간 과정에서 `errorlevel`을 `0`으로 설정할 수 있습니다.

3. **`cmd`의 실행 로직 차이**:
   - `if not`은 조건 판별에 실패하더라도 자체적으로 에러를 반환하지 않으며, 대신 비교 결과를 출력하는 데에만 초점을 맞춥니다.

---

### 해결 방법

#### 1. **`if not` 없이 직접 비교 및 처리**
`if not` 조건이 `errorlevel`을 방해한다면, 이를 제거하고 직접적으로 명령어를 실행하는 방법을 사용합니다:
```bat
if %a% neq %b% (
    copy %a% %b%
    if errorlevel 1 (
        echo 에러 발생: 복사 실패
    ) else (
        echo 복사 성공
    )
) else (
    echo 두 파일이 동일하므로 복사하지 않습니다.
)
```

#### 2. **`if not` 이후 `errorlevel` 재확인**
`if not`을 사용해야 한다면 `copy` 명령 실행 후 `errorlevel`을 다시 확인하는 방식으로 처리합니다:
```bat
if not %a% == %b% (
    copy %a% %b%
    if errorlevel 1 (
        echo 복사 실패: 경로를 확인하세요.
    ) else (
        echo 복사 성공
    )
)
```

#### 3. **명령어 별도로 실행 후 결과 확인**
`if not` 비교와 명령어 실행을 분리하여 명령어 상태를 직접 확인할 수 있습니다:
```bat
set result=0
if not %a% == %b% (
    copy %a% %b%
    set result=%errorlevel%
)

if %result% neq 0 (
    echo 복사 실패: 잘못된 경로.
) else (
    echo 복사 성공.
)
```

---

### 요약
- **이유**: `if not`이 조건 검사를 수행하며, 실행 결과와 무관하게 `errorlevel`을 변경하거나 초기화하는 경우 발생.
- **해결책**:
  1. `if not`을 제거하고 비교를 `neq`으로 변경.
  2. `copy` 명령 실행 이후에 `errorlevel` 확인.
  3. 비교와 명령어 실행을 분리해 명령 상태를 명시적으로 확인.
